TWISTING THE DOM TO OUR WILLLLLL!!!! --
__________________________________________________

WORKING WITH innerText AND textContent -- 

__________________________________________________

Now that we have seen the process on how to select elements on the DOM now we need to see how to manipulate them. 

Properties and Methods (the important ones): 
__________________________________________________  

classList 
getAttribute()
setAttribute()
appendChild()
append()
prepend()
removeChild()
remove()
createElement
innerText
textContent
innerHTML 
value 
parentElement 
children 
nextSibling 
previousSibling 
style 


In this section we are going to talk about how to get text from an element in the DOM 

lets start by selecting the h1: 

document.querySelector('h1')

save it to a variable: 
const h1 = document.querySelector('h1')


and the first property we will see is called innerText: 
h1.innerText
//"TWISTING THE DOM TO OUR WILL"

So innerText will give us the text that is inbetween both of the h1 tags.

What if we had nested innerText with a ul that had li's: 
const ul = document.querySelector('ul')

ul.innerText
//"First Thing
Second Thing
Third Thing"

the text is inside of the li but the li is a child of the ul.  When we selected the ul the children came with it. so when we call innertext 
on a parent element we get all of the text that is inside of it! 

we could also do this to get all of the text on the page: 

document.body.innerText
//"TWISTING THE DOM TO OUR WILL

Lorem, ipsum dolor sit amet consectetur adipisicing elit. Aliquam doloremque et beatae dolor quia placeat exercitationem minima vel itaque suscipit, unde velit ea earum quis maiores ex atque magni animi.

Lorem ipsum, dolor sit amet consectetur adipisicing elit. Perspiciatis dignissimos similique cupiditate adipisci sequi. Repudiandae cupiditate non corrupti quidem porro. Illum consectetur praesentium suscipit, quod laborum quibusdam aperiam nemo dolorum.

  
WELCOME

A:LKDHFLKDJ:LS"SD"F

First Thing
Second Thing
Third Thing
Carrots
Peas
Broccoli
CLICK ME!"

Reading innerText is great but we can also do things with it in the DOM-- 

Here we have out h1: 
h1.innerText
//"TWISTING THE DOM TO OUR WILL"

What if we wanted to change it? 

h1.innerText = "Hello there!"
//"Hello there!"

Obviously when we refresh the page the changes would be gone since we are only doing it in the DOM- 
But if we ran it in a script we could change it permanantly 

It's pretty silly to update the innerText of an h1 when we could just update the HTML, but thats where events come in. 

If we wanted to update the ul: 

ul.innerText = "I AM A BIG UL"
//"I AM A BIG UL"

All three of the li's are now gone. 

There is a second way to access the text within an element on the DOM and that way is called textContent.  On the surface it might seem the same 
as innerText
Heres our h1 again: 

const h1 = document.querySelector('h1')
h1.innerText
//"TWISTING THE DOM TO OUR WILL"

h1.textContent
//"TWISTING THE DOM TO OUR WILL"

we can also set content the same way we did before: 

h1.textContent = "AHH IVE CHANGED"
//"AHH IVE CHANGED"

lets look at our p tag with an in id of main: 

In the html it looks like this: 

    <p id="main">Lorem ipsum, dolor sit amet consectetur adipisicing elit. Perspiciatis dignissimos similique cupiditate
        adipisci
        sequi. Repudiandae cupiditate non corrupti quidem porro. Illum consectetur praesentium suscipit, quod laborum
        quibusdam aperiam nemo dolorum.</p>
It definitely has some weird spacing going on but now lets grab it in a variable and compare with innerText and textContent:

const p = document.querySelector('#main')


p.innerText
"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Perspiciatis dignissimos similique cupiditate adipisci sequi. Repudiandae cupiditate non corrupti quidem porro. Illum consectetur praesentium suscipit, quod laborum quibusdam aperiam nemo dolorum."

p.textContent
"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Perspiciatis dignissimos similique cupiditate
        adipisci
        sequi. Repudiandae cupiditate non corrupti quidem porro. Illum consectetur praesentium suscipit, quod laborum
        quibusdam aperiam nemo dolorum."

It knows about the dynamic spacing that is going on within the HTML if you added anything else like a script tag with the p tag that would 
show up as well: 

innerText: 
p.innerText
"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Perspiciatis dignissimos similique cupiditate adipisci sequi. Repudiandae cupiditate non corrupti quidem porro. Illum consectetur praesentium suscipit, quod laborum quibusdam aperiam nemo dolorum."

textContent: 
p.textContent
"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Perspiciatis dignissimos similique cupiditate
        adipisci
        sequi. Repudiandae cupiditate non corrupti quidem porro. Illum consectetur praesentium suscipit, quod laborum
        quibusdam aperiam nemo dolorum.
        console.log("HI!")
    "
the innerText will look at only the innerText that is showing up on the DOM, textContent will show all text within an element.  It will show
all text and text that is meant to be hidden 

That is the difference between innerText and textContent, you can use both of them to access the text within the DOM one will give you wayyyyy
more than the other one. 



innerHTML -- 
__________________________________________________
what innerHTML is going to do is retreive or return not only the text inside of an element but also all given tags inside of an element 
so if we were to select form.innerHTML we would get all of the elements inside that form as well 

const form = document.querySelector('form')

form.innerText
//"  "

BUT IF WE USE innerHTML: 

form.innerHTML
//"
        <input type="text" placeholder="Username">
        <input type="password" placeholder="Password">
        <input type="submit">
    "
We recieve a string with all of the elements inside 


Now lets do it on the ul : 

const ul = document.querySelector('ul')

ul.innerHTML
//"
        <li class="special">First Thing</li>
        <li>Second Thing</li>
        <li class="special">Third Thing</li>
    "


We also now can update elements by setting values with innerHTML like so: 

form.innerHTML = 'adad;kfja;dklja;sdlfjka'
//"adad;kfja;dklja;sdlfjka"

That whole form now that contained three different elements is now just jibberish 


But we can now also add HTML elements into the HTML page or the DOM: 
By setting the value to a string we can write HTML in the value of innerHTML and update the DOM 

form.innerHTML = '<b>I AM A BOLD TAG</b>'
//"<b>I AM A BOLD TAG</b>"

By doing this it is parsing the string and taking out the bits and figuring out what is in there and where it should be 
then it will reflect those changes in the DOM 

another thing about innerHTML is that you can add things to elements without irradicating them completely lets look at our h1 again: 


grab it: 
const h1 = document.querySelector('h1')

find the innnerHTML: 
h1.innerHTML
"TWISTING THE DOM TO OUR WILL"

then add to it: 
h1.innerHTML += ' is so coooooooool!'
//"TWISTING THE DOM TO OUR WILL is so coooooooool!"

The difference between innerText and innerHTML: 

Lets say that we wanted to add some elements to our h1 again: 

h1.innerHTML += '<b>!?!?!?!?!?!?!?!?!?</b>'
//"TWISTING THE DOM TO OUR WILL is so coooooooool!<b>!?!?!?!?!?!?!?!?!?</b>"
We added a bold tag with some punctuation, it showed up here but the b tags did not show up on the DOM whereas if you use innerText: 

h1.innerText += '<b>!?!?!?!?!?!?!?!?!?</b>'
"TWISTING THE DOM TO OUR WILL is so coooooooool!!?!?!?!?!?!?!?!?!?<b>!?!?!?!?!?!?!?!?!?</b>"

It will think that you want those b tags as a literal part of your h1 text and will show up in the DOM.
It wont treat them as elemments and will not parse them, it will treat them as literal text in between the element you are adding on to 


innerText -- will take the string you pass in and treat it as literal text 
innerHTML -- will take the string that you pass in and parse it and know that you are trying to add elements as well! 




VALUE, SRC, HREF AND MORE -- 
__________________________________________________

these are individual properties that we can directly access on elements -- 

if we want to access the information passed into a form we have an attribute that we can call- value 

VALUE - 

lets grab the elements: 
document.querySelectorAll('input')
//NodeList(5) [input, input, input, input, input]

we'll save it to a variable: 
const inputs = document.querySelectorAll('input')


Currently with an empty from the values are "" or empty:
inputs[0].value
//"" 

but what if we just filled out the first input with our name and called value on it:

inputs[0].value
//"Bennnnnnnnn"

This is the way we can obtain information from the form itself, by finding the appropraite input iundex and calling value on it it will return a 
string with what the user typed in. 

what about the checkbox beofre and after you check it? 

inputs[2].value
//"on"

This shows up for both.  If we look at the 2nd input object we will see that instead of value for checkboxes they have a property called checked 
that returns a boolean true or false: 

when checked: 
inputs[2].checked
//true

when empty: 
inputs[2].checked
//false

you can set values or add to them by using the '=' or to add '+=' and in the form it will up.  

with JS you can also clear any preexisting values by setting it to an empty string: 

grab the value and set it: 

inputs[0].value = ''

You can also change the placeholder text by grabbing the same input element and setting it to .placeholder: 

inputs[1].placeholder 
//"Password"

If we want to change it: 

inputs[1].placeholder = "Please enter a password!"
//"Please enter a password!"

It will now reflect your changes on the DOM until you refresh. 


HREF -- 

Now lets add an anchor tag to the HTML find it in the DOM save it to a variable and call .href on it: 

a.href
//"http://www.cats.com/cute"

we could also change the link if we wanted to by doing the following 

a.href = 'http://www.google.com'
//"http://www.google.com"



SRC -- 

We also have a way to change the image on the DOM through its attribute of SRC in the HTML: 

first select the image: 

document.querySelector('img')

save it to a variable: 

const img = document.querySelector('img')


call .src on img: 
img.src
//"https://images.pexels.com/photos/6016037/pexels-photo-6016037.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260"

and if we want to change it: 

img.src = 'https://images.pexels.com/photos/3135649/pexels-photo-3135649.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260'


img.src = 'https://images.pexels.com/photos/3135649/pexels-photo-3135649.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260'
//"https://images.pexels.com/photos/3135649/pexels-photo-3135649.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260"


The DOM should now have updated the changes you have made in the console. 




GETTING AND SETTING ATTRIBUTES -- 
__________________________________________________

now we are dealing with two methods: 
getAttribute()
setAttribute()

Exactly how they sound they allow us to get or set attributes on an element 

Lets look at our range input find it and set it to a variable: 

const range = document.querySelector('input[type=range]')

so with this input we have different attributes: 
<input type="range" min="100" max="500" step="50">

so if we wanted to know or get the max attribute for range we could do it this way: 

range.getAttribute('max')
//"500"
range.getAttribute('min')
//"100"
range.getAttribute('type')
//"range"
range.getAttribute('step')
//"50"

We can also change or set the arrtibutes as well, this method will take two arugments- the attribute name and the value you want to change it too:

range.setAttribute('min', '-500')

range.getAttribute('min')
//"-500"

we could even change the type of input: 

range.setAttribute('type', 'radio');



FINDING PARENT/CHILDREN/SIBLINGS -- 
__________________________________________________

parentElement, children, nextSibling, previousSibling

they allow you to access other elements based off the current element that you are working with 

SO lets grab the first li on the page and save it to a variable: 

const firstLi = document.querySelector('li')

if we inspect the element: 

console.dir(firstLi)

We see that it has a property called parentElement and it is referencing a ul: 

parentElement: ul

So this is a connection that is pointing upwards, its how we can find the parent of the given element we are working with. 
And we can access it by typing: 

firstLi.parentElement
//<ul>​…​</ul>

​We could also call the parentElement on the parentElement and what do you think we will see: 

firstLi.parentElement.parentElement
<body>​…​</body>​

THE BODY!!!!! 

And so on and so forth until it becomes null 

We also have the children, since li's have no children lets find something that does and save it to a variable: 

const ul = document.querySelector('ul')

if we want to access the ul's children: 

ul.children
HTMLCollection(3) [li.special, li, li.special]

This is another array like object, and contains the children elements of this ul, and they are in order of apperance in the DOM.

Lets say we wanted to find the next sibling of the first li: 

we find our first li again and save it to a variable: 

const firstLi = document.querySelector('li')

and then we call: 
firstLi.nextElementSibling
<li>​…​</li>​

Which gives us our next li of 'Second Thing' because they share a parent- the ul 

And this will give us our third li: 

firstLi.nextElementSibling.nextElementSibling
<li class=​"special">​::marker​"Third Thing"</li>​

IF we wanted to work backwards from the thrid li we would save it to a variable and call previousSibling: 

const thridLi = firstLi.nextElementSibling.nextElementSibling

and then call the mehtod on it: 

thridLi.previousElementSibling
<li>​::marker​"Second Thing"</li>​

We end up obtaining the second li! 

These properties are nice to use when you need to find the parent of a child node or the child node of a parent. 




CHANGING MULTIPLE ELEMENTS -- 
__________________________________________________

START HERE TOMORROW!!! 







































